# II. 构造数据抽象

*数据的封装和解包，来模拟真实生活中复杂的数据情况。*

## 数据抽象导引

### 抽象屏障

隔离了系统中不同数据的层次，使得我们在使用上层数据的时候，不必关心底层数据的结构。

### 数据的定义

我们总可以将数据定义为一组适当的**选择函数**与**构造函数**，以及为使这些过程成为一套合法表示，他们就必须满足的一组特定条件。

* 选择函数：提取出数据的某一部分，大部分语言中通过域访问符访问内部数据
* 构造函数：通过某种方法将更低抽象层次的数据符合成更高抽象层次的数据

> 这只是一种简单的理解方式。严格的形式化有两种，第一种为**抽象模型**方法，即更高级的数据总是根基于已有数据的类型，新对象的断言可以规约于已有数据的断言；另一种为**代数规范**，它将**过程**看作抽象代数系统的元素，系统的行为由公理刻画，并通过抽象代数的技术检查有关数据对象的断言。

* 练习2.4 序对的两种过程表达方式

  ```scheme
  ; way 1
  (define (cons x y)
    (define (dispatch m)
      (cond ((= m 0) x)
            ((= m 1) y)
            (else (error "Argument not 0 or 1 -- CONS" m))))
    dispatch)
  (define (car z) (z 0))
  (define (cdr z) (z 1))
  ; way 2
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
  (define (cdr z)
    (z (lambda (p q) q)))
  ```

* 练习2.6 Church计数（更出名的叫法是$\lambda$演算）

  ```scheme
  ;0是一个lambda表达式，它接受一个参数，始终返回一个固定的lambda表达式，这个lambda表达式返回它所接受的一个参数
  (define zero (lambda (f) (lambda (x) x)))
  ;自增的表示，将其与0的表达式比较，最内层不再是一个不动点，而是一个复杂的嵌套
  (define (add-one n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
  ;one = (add-one zero)
  ;	 = (lambda (f1) (lambda (x1) (f1 (((lambda (f2) (lambda (x2) x2))) f1) x1)))
  ;	 = (lambda (f1) (lambda (x1) (f1 ((lambda (x2) x2) x1)))
  ;	 = (lambda (f1) (lambda (x1) (f1 (x1))))
  ; 	 = (lambda (f) (lambda (x) (f x))
  ; 可以从1的计算中看出，随着自增，最内层的lambda返回值逐渐变为f(n),f(f(n))...
  
  ;add
  ;本质是把内部的f^n(x)和f^m(x)嵌套成f^(n+m)(x)
  ;分别给相同的参数x，得到f^n(x)和f^m(x)
  ;随后将一个作为另一个的参数，再用一层lambda进行封装，即可实现嵌套
  (define (add n m)
    (lambda (f) (lambda (x) ((n f) ((m f) x)))))
  
  ;multiply
  ;本质是把内部的f^n(x)的和f^m(x)运算得到f^mn(x)
  ;观察Church形式，将f^m(x)作为n的参数，即f的位置
  ;即可将n中的n层f全都换成f^n，得到f^mn(x)，再套一层lambda
  (define (mul n m)
    (lambda (f) (lambda (x) ((n (m x)) x))))
  ```

  