# II. 构造数据抽象

*数据的封装和解包，来模拟真实生活中复杂的数据情况。*

## 数据抽象导引

### 抽象屏障

隔离了系统中不同数据的层次，使得我们在使用上层数据的时候，不必关心底层数据的结构。

### 数据的定义

我们总可以将数据定义为一组适当的**选择函数**与**构造函数**，以及为使这些过程成为一套合法表示，他们就必须满足的一组特定条件。

* 选择函数：提取出数据的某一部分，大部分语言中通过域访问符访问内部数据
* 构造函数：通过某种方法将更低抽象层次的数据符合成更高抽象层次的数据

> 这只是一种简单的理解方式。严格的形式化有两种，第一种为**抽象模型**方法，即更高级的数据总是根基于已有数据的类型，新对象的断言可以规约于已有数据的断言；另一种为**代数规范**，它将**过程**看作抽象代数系统的元素，系统的行为由公理刻画，并通过抽象代数的技术检查有关数据对象的断言。

* 练习2.4 序对的两种过程表达方式

  ```scheme
  ; way 1
  (define (cons x y)
    (define (dispatch m)
      (cond ((= m 0) x)
            ((= m 1) y)
            (else (error "Argument not 0 or 1 -- CONS" m))))
    dispatch)
  (define (car z) (z 0))
  (define (cdr z) (z 1))
  ; way 2
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
  (define (cdr z)
    (z (lambda (p q) q)))
  ```

* 练习2.6 Church计数（$\lambda$演算衍生出的一种计数方式）

  ```scheme
  ;0是一个lambda表达式，它接受一个参数，始终返回一个固定的lambda表达式，这个lambda表达式返回它所接受的一个参数
  (define zero (lambda (f) (lambda (x) x)))
  ;自增的表示，将其与0的表达式比较，最内层不再是一个不动点，而是一个复杂的嵌套
  (define (add-one n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
  ;one = (add-one zero)
  ;	 = (lambda (f1) (lambda (x1) (f1 (((lambda (f2) (lambda (x2) x2))) f1) x1)))
  ;	 = (lambda (f1) (lambda (x1) (f1 ((lambda (x2) x2) x1)))
  ;	 = (lambda (f1) (lambda (x1) (f1 (x1))))
  ; 	 = (lambda (f) (lambda (x) (f x))
  ; 可以从1的计算中看出，随着自增，最内层的lambda返回值逐渐变为f(n),f(f(n))...
  
  ;add
  ;本质是把内部的f^n(x)和f^m(x)嵌套成f^(n+m)(x)
  ;分别给相同的参数x，得到f^n(x)和f^m(x)
  ;随后将一个作为另一个的参数，再用一层lambda进行封装，即可实现嵌套
  (define (add n m)
    (lambda (f) (lambda (x) ((n f) ((m f) x)))))
  
  ;multiply
  ;本质是把内部的f^n(x)的和f^m(x)运算得到f^mn(x)
  ;观察Church形式，将f^m(x)作为n的参数，即f的位置
  ;即可将n中的n层f全都换成f^n，得到f^mn(x)，再套一层lambda
  (define (mul n m)
    (lambda (f) (lambda (x) ((n (m x)) x))))
  ```

* 练习2.13

  >par1 A B
  >= div-interval (mul-interval A B) (add-interval A B) 
  >
  >= mul-interval ($(A*B)_{min}$, $(A*B)_{max}$) ($\frac{1}{(A+B)_{max}}$, $\frac{1}{(A+B)_{min}}$)
  >
  >= ($\frac{(A*B)_{min}}{(A+B)_{max}}$, $\frac{(A*B)_{max}}{(A+B)_{max}}$)
  >
  > 
  >
  >par2 A B
  >
  >= div-interval (1, 1) (add-interval ($\frac{1}{A_{max}}$, $\frac{1}{A_{min}}$) ($\frac{1}{B_{max}}$, $\frac{1}{B_{min}}$))
  >
  >= div-internal (1, 1) ($\frac{1}{A_{max}}+\frac{1}{B_{max}}$, $\frac{1}{A_{min}}+\frac{1}{B_{min}}$)
  >
  >= mul-interval (1, 1) ($\frac{A_{min}B_{min}}{A_{min}+B_{min}}$, $\frac{A_{max}B_{max}}{A_{max}+B_{max}}$)
  >
  >= ($\frac{A_{min}B_{min}}{A_{min}+B_{min}}$, $\frac{A_{max}B_{max}}{A_{max}+B_{max}}$)
  >
  >// 在符号不同时可能出错？

* 练习2.16

  ```scheme
  ;TODO
  ```

## 层次性数据和闭包性质

### 序列的表示

* 序列的本质就是将序对作为序对的元素。Haskell和Lisp中的序对是一种特殊的广义表，满足其`cdr`要么是一个子表，要么是一个特殊的序对元素`nil`。

* 练习2.17

  ```scheme
  (define (last-pair ls)
    (if (= (cdr ls) nil)
        (car ls)
        (last-pair (cdr ls))))
  ```

* 练习2.18

  ```scheme
  (define (reverse ls)
    (define (reverse-iter ls accu)
      (if (= (cdr ls) nil)
          (cons (car ls) accu)
          (reverse-iter (cdr ls) 
                        (cons (car ls) 
                              accu))))
    (reverse-iter ls nil))
  ```

* 练习2.20

  ```scheme
  (define (f x y . z) <body>)
  ;x,y之后的所有元素作为一个列表参数
  ```

* 列表映射

  ```scheme
  ;map 将函数运用到列表的每个元素
  (define (map proc ls)
    (if (null? ls)
        nil
        (cons (proc (car ls))
              (map proc (cdr ls)))))
  ;filter和reduce好像还在后面
  ```

### 层次性结构

* 若将序对作为序对的元素，那么将形成一个树状结构。列表是特殊的树。

* 对树的映射`map`，只需要略微修改对列表的映射。但貌似没有什么很好的迭代过程，只能递归：

  ```scheme
  (define (map proc tree)
    (cond ((null? tree) nil)
          ((not (pair? tree)) (proc tree))
          (else (cons (map proc (car tree))
                      (map proc (cdr tree)))))
  ```

### 序列作为一种约定的界面

序列是一种有组织的数据形式，而这一组织型可以被有效利用：对序列的处理流程可以描述为一些步骤，而一些看似不同的流程其实可以抽象为相似的步骤，并用相同的接收过程为参数的过程来描述；步骤的流程看作信号流，则不同步骤切换之间的信号则是决定过程切换的关键参数。例子：分支条件判断信号、递归终止信号等等。

其实上面这段都是正确的废话。作为例子，我们来看看函数式语言处理序列时最常用的过程之一`filter`：

```scheme
(define (filter predictate sequence)
  (cond ((null? sequence) nil)
        ((predictate (car sequence))
         (cons (car sequence)
               (filter predictate (cdr sequence))))
        else (filter predictate (cdr sequence))))
```

通过这一过程，我们可以将所有满足`predictate`条件的元素保留下来而去除其他元素，保留的元素保持原顺序。这里的`predictate`并不确定，也就是我们前面提到的条件信号，而`null?`则是终止信号。

另有一个常用的过程`accumulate`，没记错的话在Haskell里叫`zip`，也是大家在python里熟知的`reduce`。它的作用是将一个序列的所有元素按某种运算规则进行运算，最终得到一个值。

```scheme
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
```

`map`，`filter`和`accumulate`不仅是序列处理的三大强力工具，更是函数式编程思想中模块化的典型体现。

* 练习2.33

  ```scheme
  ; use accumulate to define map
  (define (map p sequence)
    (accumulate (lambda (x y)
                  	  (cons (p x) 
                              y)) 
                nil 
                sequence))
  ; cat two sequence
  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))
  ; get the length of seq
  (define (length seq)
    (accumulate add 0 seq))
  ```

* 后面几道练习

  ```scheme
  ; TODO
  ```

* 嵌套映射

  迭代过程中将当前迭代元素作为参数构造新的映射，可以类比其它语言中的嵌套循环。通过这种方式，前面提到的序列处理流程可以运用于更加复杂的嵌套结构中。

* 练习2.42 序列映射-八皇后

  ```scheme
  ; 递归 过滤 扩大规模
  (define (queens board))
  ```

  





