# II. 构造数据抽象

*数据的封装和解包，来模拟真实生活中复杂的数据情况。*

## 数据抽象导引

### 抽象屏障

隔离了系统中不同数据的层次，使得我们在使用上层数据的时候，不必关心底层数据的结构。

### 数据的定义

我们总可以将数据定义为一组适当的**选择函数**与**构造函数**，以及为使这些过程成为一套合法表示，他们就必须满足的一组特定条件。

* 选择函数：提取出数据的某一部分，大部分语言中通过域访问符访问内部数据
* 构造函数：通过某种方法将更低抽象层次的数据符合成更高抽象层次的数据

> 这只是一种简单的理解方式。严格的形式化有两种，第一种为**抽象模型**方法，即更高级的数据总是根基于已有数据的类型，新对象的断言可以规约于已有数据的断言；另一种为**代数规范**，它将**过程**看作抽象代数系统的元素，系统的行为由公理刻画，并通过抽象代数的技术检查有关数据对象的断言。

* 练习2.4 序对的两种过程表达方式

  ```scheme
  ; way 1
  (define (cons x y)
    (define (dispatch m)
      (cond ((= m 0) x)
            ((= m 1) y)
            (else (error "Argument not 0 or 1 -- CONS" m))))
    dispatch)
  (define (car z) (z 0))
  (define (cdr z) (z 1))
  ; way 2
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
  (define (cdr z)
    (z (lambda (p q) q)))
  ```

* 练习2.6 Church计数（$\lambda$演算衍生出的一种计数方式）

  ```scheme
  ;0是一个lambda表达式，它接受一个参数，始终返回一个固定的lambda表达式，这个lambda表达式返回它所接受的一个参数
  (define zero (lambda (f) (lambda (x) x)))
  ;自增的表示，将其与0的表达式比较，最内层不再是一个不动点，而是一个复杂的嵌套
  (define (add-one n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
  ;one = (add-one zero)
  ;	 = (lambda (f1) (lambda (x1) (f1 (((lambda (f2) (lambda (x2) x2))) f1) x1)))
  ;	 = (lambda (f1) (lambda (x1) (f1 ((lambda (x2) x2) x1)))
  ;	 = (lambda (f1) (lambda (x1) (f1 (x1))))
  ; 	 = (lambda (f) (lambda (x) (f x))
  ; 可以从1的计算中看出，随着自增，最内层的lambda返回值逐渐变为f(n),f(f(n))...
  
  ;add
  ;本质是把内部的f^n(x)和f^m(x)嵌套成f^(n+m)(x)
  ;分别给相同的参数x，得到f^n(x)和f^m(x)
  ;随后将一个作为另一个的参数，再用一层lambda进行封装，即可实现嵌套
  (define (add n m)
    (lambda (f) (lambda (x) ((n f) ((m f) x)))))
  
  ;multiply
  ;本质是把内部的f^n(x)的和f^m(x)运算得到f^mn(x)
  ;观察Church形式，将f^m(x)作为n的参数，即f的位置
  ;即可将n中的n层f全都换成f^n，得到f^mn(x)，再套一层lambda
  (define (mul n m)
    (lambda (f) (lambda (x) ((n (m x)) x))))
  ```

* 练习2.13

  >par1 A B
  >= div-interval (mul-interval A B) (add-interval A B) 
  >
  >= mul-interval ($(A*B)_{min}$, $(A*B)_{max}$) ($\frac{1}{(A+B)_{max}}$, $\frac{1}{(A+B)_{min}}$)
  >
  >= ($\frac{(A*B)_{min}}{(A+B)_{max}}$, $\frac{(A*B)_{max}}{(A+B)_{max}}$)
  >
  > 
  >
  >par2 A B
  >
  >= div-interval (1, 1) (add-interval ($\frac{1}{A_{max}}$, $\frac{1}{A_{min}}$) ($\frac{1}{B_{max}}$, $\frac{1}{B_{min}}$))
  >
  >= div-internal (1, 1) ($\frac{1}{A_{max}}+\frac{1}{B_{max}}$, $\frac{1}{A_{min}}+\frac{1}{B_{min}}$)
  >
  >= mul-interval (1, 1) ($\frac{A_{min}B_{min}}{A_{min}+B_{min}}$, $\frac{A_{max}B_{max}}{A_{max}+B_{max}}$)
  >
  >= ($\frac{A_{min}B_{min}}{A_{min}+B_{min}}$, $\frac{A_{max}B_{max}}{A_{max}+B_{max}}$)
  >
  >// 在符号不同时可能出错？

* 练习2.16

  ```scheme
  ;TODO
  ```

## 层次性数据和闭包性质

### 序列的表示

* 序列的本质就是将序对作为序对的元素。Haskell和Lisp中的序对是一种特殊的广义表，满足其`cdr`要么是一个子表，要么是一个特殊的序对元素`nil`。

* 练习2.17

  ```scheme
  (define (last-pair ls)
    (if (= (cdr ls) nil)
        (car ls)
        (last-pair (cdr ls))))
  ```

* 练习2.18

  ```scheme
  (define (reverse ls)
    (define (reverse-iter ls accu)
      (if (= (cdr ls) nil)
          (cons (car ls) accu)
          (reverse-iter (cdr ls) 
                        (cons (car ls) 
                              accu))))
    (reverse-iter ls nil))
  ```

* 练习2.20

  ```scheme
  (define (f x y . z) <body>)
  ;x,y之后的所有元素作为一个列表参数
  ```

* 列表映射

  ```scheme
  ;map 将函数运用到列表的每个元素
  (define (map proc ls)
    (if (null? ls)
        nil
        (cons (proc (car ls))
              (map proc (cdr ls)))))
  ;filter和reduce好像还在后面
  ```

### 层次性结构

* 若将序对作为序对的元素，那么将形成一个树状结构。列表是特殊的树。

* 对树的映射`map`，只需要略微修改对列表的映射。但貌似没有什么很好的迭代过程，只能递归：

  ```scheme
  (define (map proc tree)
    (cond ((null? tree) nil)
          ((not (pair? tree)) (proc tree))
          (else (cons (map proc (car tree))
                      (map proc (cdr tree)))))
  ```

### 序列作为一种约定的界面







